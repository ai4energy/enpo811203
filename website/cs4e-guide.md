@def title = "适用于工科的计算入门导引"
@def tags = ["compter science", "guide"]

# 适用于工科的计算入门导引

伴随着物联网、大数据、云计算及三维可视化等技术的发展，在“碳达峰、碳中和”双碳目标驱动下，传统工业领域数字化、智能化已经成为第四次工业革命的重要方向之一，这也是中国制造2025的主攻方向。

未来是万物互联、数字孪生、端边云协同的时代。云、大、智、物、移等等是智慧能源绕不开的内容。从数字化到智能化是一个过程，而智能化是整个框架的核心。云、大、物、移都是IT技术。我们需要对计算机有所了解和认识，并能与行业领域专门知识结合，才能更有利于我们塑造智慧化的未来。

那么，非IT工科专业，计算机如何入门呢？

计算就是机械化的信息处理。这点可以先读一读王垠的[《解谜计算机科学》](http://www.yinwang.org/blog-cn/2018/04/13/computer-science)有个认识和了解。接下来，我们会从函数、递归、模型处理、抽象等几个方面进行介绍。

## 函数

有很多人说，计算机入门最合适的捷径就是编程。很多人的编程是从c语言开始的，一开始就陷入了printf的格式化输入里去。而我们这里高度概括的来讲讲。

### 编程就是写函数

对，编程就是写函数。很多人接触的c语言入门的第一个程序差不多长这样：
```c
#include <stdio.h>
int main() {
    printf("Hello, World!\n");
    return 0;
}
```
而有些学院因为涉及到很多计算密集型的计算，编程采用了Fortran，hello world程序像这样：
```fortran
program main
write(*,*) "Hello, World!"
end program
```
的确，这就是写的函数，是主函数。

- **函数可能有返回值，也可能没有返回值**

像刚才的c代码，return 0返回了整数0。而早期的c语言如果使用void main也是可以，但是却不是标准的语法：
```c
#include <stdio.h>
void main() {
    printf("Hello, World!\n");
}
```
事实上，操作系统会根据程序的返回值判断是否正确执行了。比如bash下，我们执行一条命令之后，可以用`echo $?`来查看上一条命令的返回值。而在windows下，如果使用的是命令行终端(cmd.exe)，可以用`echo %errorlevel%`来查看上一条命令的返回值，如果使用的的是powershell，可以用`$LASTEXITCODE`来获取上一条命令的返回值。

通常程序返回0代表程序正确结束。所以我们c的主函数一般都是int的返回类型，最后有一句return 0。

- **编程的函数不同于数学上的函数**

虽然编程的函数和数学上的函数都使用了function这个词，但含义是不一样的。

数学上的函数就是个定义，比如$y=\sqrt{x}$，描述的就是有个y，其平方是x。

但是编程上的函数是一系列的操作过程，找到这个y，使得其平方是我们给出的那个x。比如我们可以把$y=\sqrt{x}$变形，得到$y^2=x$, 或者说$y=x/y$，那么我们对给定的某个x（如2），我们可以给个y的初值1进去迭代，我们会发现y就在1和2之间“震荡”，那我们可以用旧的y和新的y算术平均$y_{new}=\frac{1}{2}(y_{old}+x/y_{old})$或者加权平均$y_{new}=\alpha y_{old}+(1-\alpha)(x/y_{old})$，来进行迭代，从而找到那个我们希望的y值。

- **函数能被调用，能被嵌套的调用**

写函数的目的实际上是把具有一定功能性代码整合起来，可以重复的使用，也就是可以被调用。比如如下的代码，主函数main调用了fun1，而fun1又调用了fun2：

```c
include <stdio.h>
int fun1()
{
    printf("I am in fun1");
    fun2();
    return 0;
}

int fun2()
{
    printf("I am in fun2");
    return 0;
}

int main()
{
    fun1();
    return 0;
}
```

- **函数可能会改变参数本身的内容，也可能不会**

数学上的函数定义是这样的：给定一个集合A，对于集合X中的每一个元素x，在集合Y中都有唯一的一个元素y和x对应。

事实上，编程中的函数，给定输入的参数x，执行一定的操作，但是这些操作不改变x，那么这样的函数是没有改变参数本身的内容。然而有的函数是会改变参数本身的内容的。比如给你一个数组，调用一个排序函数来排序，以原来的数组名返回排序之后的数组，其实就是改变了参数的内容。

在fortran中，有subroutine和function之分，可以认为function就是纯的函数，而subroutine可以使用参数来承接函数调用之后对参数的改变。

而在c中，如果我们写个交换函数swap，使用传地址的方式进行传参数，实际上也改变了参数本身的内容。

在Julia中，如果一个函数名以！结尾，表明它会改变输入参数的内容。而不带！的函数名，只是会有返回值，不会改变输入参数的值。

- **函数并不一定有名字**

可以认为，没有名字的函数可以使用一次，然后没法再次唤醒它。
在一些语言中，没有名字的函数可以使用lambda表达式进行定义。比如scheme,
```scheme
(lambda (x) (+ x 2))
```

又比如python，
```python
lambda x: x+2
```

在javascript中则可以这样定义函数，
```javascript
x-> x+2
```

甚至，C++，
```C++
[](float x)->float{return x+2;};
```

没有名字有什么用呢？其实有的，比如在python中，可以使用map来调用一次，
```python
map(lambda x: x+2, [1,3,5,7])
```

比如scheme这样调用，
```scheme
((lambda (x) (+ x 2)) 4)
```
当然，javacript和c++也可以类似的对匿名函数进行使用。

但是匿名函数使用一次，没法在想用的时候再次召唤出来。所以我们可以给它取个名字，就好比给锅安装了个柄，可以通过柄把锅抓住。

如下的C++把匿名函数取了个名字addfunciton，并调用它，
```C++
auto addfunction=[](float x)->float{return x+2;};
addfunction(3)
```

如下的python代码把匿名函数取了个名字add2，并调用它
```python
add2 = lambda x: x+2
add2(3)
```

如下的scheme代码把匿名函数取了个名字add2，并调用它
```scheme
(define add2
  (lambda (x) (+ x 2)))
(add2 3)
```

给函数取名，是因为我们要方便我们在需要的时候召唤它。

- **加减乘除本质就是函数**
parse，运算符与函数，前缀表达式与中缀表达式
c++的运算符重载，python的__add__，julia的Base.+

- **主函数并不是必须的，但运行程序必须有个入口**
julia的、python的、java的入口有什么差异

- **提供给函数的参数需要按约定好的要求**
函数的参数

- **函数可以封装成库给别人调用，有动态库，有静态库**
dll，lib，so，a，dylib，

- **函数能跨语言调用**
dll被python调用，dll被julia调用，在fortran与c混合编程中iso_c_binding的桥梁作用

- **可执行程序就是个函数，但是函数参数的给定方式是命令行参数**
c语言的命令行参数，fortran程序的命令行参数

- **程序执行时的环境变量也会影响函数的行为**

- **函数运行时的“环境”与闭包**
，盗梦空间，打游戏的技能表，栈

- **事件驱动与死循环，服务程序**

- 对死循环程序的控制，任务管理器与上帝之手

- 操作系统就是最初的那个根函数

- c++的函数模板与泛型编程

- 动态类型语言与静态类型语言，及它们的互相靠拢
python的类型提示

## 模型与符号

- 从符号到模型与parser

- 函数的调用就是用它来处理你的模型

- 模型处理与代码生成

- 编译器也是个函数

c语言的编译过程，c编译到汇编，汇编编译到0101，链接，

- 移植、平台与上层无关性

- make与makefile以及项目文件

- 从make，到automake，configure，再到qmake，wmake，以及cmake

- cmake也是个函数



## 递归

- 斐波拉契数列与递归

- 递归与循环

- 四则混合运算、表达式树与递归

## 交互式编程与解释器

我们提交一个Add 3 4

- 抽象语法树

- 递归处理是解释器的处理办法

## 抽象与封装

- 结构体，有理数的加减乘除

- 结构体演变为类

- 以类为基础的面向对象编程，封装，继承，多态

- 算法的不依赖于具体的类型
C++的模板类
julia的参数类型

- java的java、class、jar

- julia的多重分发

- go的嵌入体

- 库与头文件、包、模块

- 软件包与生态

- 名字空间

## 图形界面与低代码开发
- 从gcc、gdb到IDE
- 儿童编程Scratch与背后的code
-从delphi、C#、QT到浏览器



## 如何进行进一步学习
- 学习一门编程语言，掌握关键语言特性，忽略次要特性
- 注意语言特有的那些区别于其他语言的地方
- 编程与算法，sicp与leecode
- 食材、调料与大餐
- 搜索引擎、github

## 再看抽象与封装
- 硬件的一层又一层抽象
- 对用户友好与对机器友好
从javascript到typescript
从0101到汇编到c，再到今天的高级语言
- 软件的一层又一层抽象
从ops说说计算方法与硬件无关性
DSL与库
- 知识的结构
欧几里得几何原本

自然数的定义

让我们谈谈lambda演算

lisp的本质，xml，ant

- 站在巨人的肩膀上

## 不是最后的最后

吾生也有涯，而知也无涯

知识在爆炸，与时俱进

从下到上的学习与从上到下的做事，不同的阶段，框架与细节相结合

学习与成功五要素，学习的能力、学习的驱动力、学习的路径、机缘、持续努力

前进的方法：实践、认识、再实践、再认识