<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/enpo811203/libs/katex/katex.min.css"> <link rel=stylesheet  href="/enpo811203/libs/highlight/github.min.css"> <link rel=stylesheet  href="/enpo811203/css/franklin.css"> <link rel=stylesheet  href="/enpo811203/css/poole_hyde.css"> <link rel=stylesheet  href="/enpo811203/css/custom.css"> <style> html { font-size: 17px; } .franklin-content { position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em; } @media (min-width: 940px) { .franklin-content { width: 100%; margin-left: auto; margin-right: auto; } } @media (max-width: 768px) { .franklin-content { padding-left: 6%; padding-right: 6%; } } </style> <link rel=icon  href="/enpo811203/assets/favicon.png"> <title>适用于工科的计算入门导引</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/enpo811203/assets/ai4energylogo.png" style="width: 200px; height: auto; display: inline"> <h1 style="font-size:1em; opacity: 0.95;"><a href="/enpo811203/">智慧能源系统导论</a></h1> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9"> <a class="sidebar-nav-item " href="https://ai4energy.github.io/">Ai4Energy主页</a> <!-- <a class="sidebar-nav-item {{ispage /installation/}}active{{end}}" href="/enpo811203/installation/">Software installation</a> <a class="sidebar-nav-item {{ispage /cheatsheets/}}active{{end}}" href="/enpo811203/cheatsheets/">Cheatsheets</a> <a class="sidebar-nav-item {{ispage /hw0/}}active{{end}}" href="/enpo811203/hw0/"><b>作业 0</b></a> --> <br> <small style="text-transform: uppercase; font-size: 0.75em">课程内容</small> <div class=week >第〇篇 绪论篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture1/"><b>第1讲</b> - <em>智慧能源引论</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture2/"><b>第2讲</b> - <em>实践之路概述</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw1/"><b>作业 1</b></a> <div class=week >第一篇 IT篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture3/"><b>第3讲</b> - <em>云服务基础</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture4/"><b>第4讲</b> - <em>物联网系统</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture5/"><b>第5讲</b> - <em>相关IT知识</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw1/"><b>作业 1</b></a> <div class=week >第二篇 建模篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture6/"><b>第6讲</b> - <em>能源系统建模概述</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture6/"><b>第6讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw2/"><b>作业 2</b></a> <div class=week >第三篇 仿真篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture5/"><b>第5讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture6/"><b>第6讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw3/"><b>作业 3</b></a> <div class=week >第四篇 优化篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture7/"><b>第7讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture8/"><b>第8讲</b> - <em>持续建设中</em></a> <div class=week >第五篇 控制篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture9/"><b>第9讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture10/"><b>第10讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw4/"><b>作业 4</b></a> <div class=week >第六篇 实践篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture11/"><b>第11讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture12/"><b>第12讲</b> - <em>持续建设中</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw5/"><b>作业 5</b></a> <div class=week >第七篇 专题篇</div> <a class="sidebar-nav-item " href="/enpo811203/lecture13/"><b>第13讲</b> - <em>相关IT知识汇编</em></a> <a class="sidebar-nav-item " href="/enpo811203/lecture14/"><b>第14讲</b> - <em>典型软件介绍</em></a> <a class="sidebar-nav-item " href="/enpo811203/hw6/"><b>作业 6</b></a> <div class=week >第八篇 附录篇</div> </nav> </div> </div> <div class="content container"> <div class=franklin-content ><h1 id="适用于工科的计算入门导引"><a href="#适用于工科的计算入门导引" class=header-anchor >适用于工科的计算入门导引</a></h1> <p>伴随着物联网、大数据、云计算及三维可视化等技术的发展，在“碳达峰、碳中和”双碳目标驱动下，传统工业领域数字化、智能化已经成为第四次工业革命的重要方向之一，这也是中国制造2025的主攻方向。</p> <p>未来是万物互联、数字孪生、端边云协同的时代。云、大、智、物、移等等是智慧能源绕不开的内容。从数字化到智能化是一个过程，而智能化是整个框架的核心。云、大、物、移都是IT技术。我们需要对计算机有所了解和认识，并能与行业领域专门知识结合，才能更有利于我们塑造智慧化的未来。</p> <p>那么，非IT工科专业，计算机如何入门呢？</p> <p>计算就是机械化的信息处理。这点可以先读一读王垠的<a href="http://www.yinwang.org/blog-cn/2018/04/13/computer-science">《解谜计算机科学》</a>有个认识和了解。也可以先看一看yuziwen的<a href="https://yuziwen.github.io/pl-tutorial-1.html">PL教程 第一章 人和机器</a>。</p> <p>接下来，我们会从函数、递归、模型处理、抽象等几个方面进行介绍。</p> <h2 id="函数"><a href="#函数" class=header-anchor >函数</a></h2> <p>有很多人说，计算机入门最合适的捷径就是编程。很多人的编程是从c语言开始的，一开始就陷入了scanf/printf的格式化输入/输出里去。而我们这里高度概括的来讲讲。</p> <h3 id="编程就是写函数"><a href="#编程就是写函数" class=header-anchor >编程就是写函数</a></h3> <p>对，编程就是写函数。很多人接触的c语言入门的第一个程序差不多长这样：</p> <pre><code class="c hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;stdio.h&gt;</span></span>
<span class=hljs-type >int</span> <span class="hljs-title function_">main</span><span class=hljs-params >()</span> {
    <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;Hello, World!\n&quot;</span>);
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <p>而有些学院因为涉及到很多计算密集型的计算，编程采用了Fortran入门，hello world程序像这样：</p> <pre><code class="julia hljs">program main
    write(*,*) <span class=hljs-string >&quot;Hello, World!&quot;</span>
<span class=hljs-keyword >end</span> program</code></pre> <p>的确，这就是写的函数，是主函数。</p> <ul> <li><p><strong>函数可能有返回值，也可能没有返回值</strong></p> </ul> <p>像刚才的c代码，return 0返回了整数0。而早期的c语言如果使用void main也是可以，但是却不是标准的语法：</p> <pre><code class="c hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;stdio.h&gt;</span></span>
<span class=hljs-type >void</span> <span class="hljs-title function_">main</span><span class=hljs-params >()</span> {
    <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;Hello, World!\n&quot;</span>);
}</code></pre> <p>事实上，操作系统会根据程序的返回值判断是否正确执行了。比如bash下，我们执行一条命令之后，可以用<code>echo &#36;?</code>来查看上一条命令的返回值。而在windows下，如果使用的是命令行终端&#40;cmd.exe&#41;，可以用<code>echo &#37;errorlevel&#37;</code>来查看上一条命令的返回值，如果使用的的是powershell，可以用<code>&#36;LASTEXITCODE</code>来获取上一条命令的返回值。</p> <p>通常程序返回0代表程序正确结束。所以我们c的主函数一般都是int的返回类型，最后有一句return 0。</p> <ul> <li><p><strong>编程的函数不同于数学上的函数</strong></p> </ul> <p>虽然编程的函数和数学上的函数都使用了function这个词，但含义是不一样的。</p> <p>数学上的函数就是个定义，比如<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">y=\sqrt{x}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8003em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal">x</span></span></span><span style="top:-2.7603em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>，描述的就是有个y，其平方是x。</p> <p>但是编程上的函数是一系列的操作过程，找到这个y，使得其平方是我们给出的那个x。比如我们可以把<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">y=\sqrt{x}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8003em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal">x</span></span></span><span style="top:-2.7603em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>变形，得到<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y^2=x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0085em;vertical-align:-0.1944em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>, 或者说<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><mi mathvariant=normal >/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">y=x/y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class=mord >/</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，那么我们对给定的某个x（如2），我们可以给个y的初值1进去迭代，我们会发现y就在1和2之间“震荡”，那我们可以用旧的y和新的y算术平均<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy=false >(</mo><msub><mi>y</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>+</mo><mi>x</mi><mi mathvariant=normal >/</mi><msub><mi>y</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">y_{new}=\frac{1}{2}(y_{old}+x/y_{old})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1.1901em;vertical-align:-0.345em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8451em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class=mord >/</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>或者加权平均<span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mi>α</mi><msub><mi>y</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>+</mo><mo stretchy=false >(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy=false >)</mo><mo stretchy=false >(</mo><mi>x</mi><mi mathvariant=normal >/</mi><msub><mi>y</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">y_{new}=\alpha y_{old}+(1-\alpha)(x/y_{old})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >1</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mclose >)</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mord >/</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>，来进行迭代，从而找到那个我们希望的y值。</p> <ul> <li><p><strong>函数能被调用，能被嵌套的调用</strong></p> </ul> <p>写函数的目的实际上是把具有一定功能性代码整合起来，可以重复的使用，也就是可以被调用。比如如下的代码，主函数main调用了fun1，而fun1又调用了fun2：</p> <pre><code class="c hljs">include &lt;stdio.h&gt;
<span class=hljs-type >int</span> <span class="hljs-title function_">fun2</span><span class=hljs-params >()</span>
{
    <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;I am in fun2&quot;</span>);
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}

<span class=hljs-type >int</span> <span class="hljs-title function_">fun1</span><span class=hljs-params >()</span>
{
    <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;I am in fun1&quot;</span>);
    fun2();
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}

<span class=hljs-type >int</span> <span class="hljs-title function_">main</span><span class=hljs-params >()</span>
{
    fun1();
    <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <ul> <li><p><strong>函数可能会改变参数本身的内容，也可能不会</strong></p> </ul> <p>数学上的函数定义是这样的：给定一个集合A，对于集合X中的每一个元素x，在集合Y中都有唯一的一个元素y和x对应。</p> <p>事实上，编程中的函数，给定输入的参数x，执行一定的操作，但是这些操作不改变x，那么这样的函数是没有改变参数本身的内容。然而有的函数是会改变参数本身的内容的。比如给你一个数组，调用一个排序函数来排序，以原来的数组名返回排序之后的数组，其实就是改变了参数的内容。</p> <p>在fortran中，有subroutine和function之分，可以认为function就是纯的函数，而subroutine可以使用参数来承接函数调用之后对参数的改变。</p> <p>而在c中，如果我们写个交换函数swap，使用传地址的方式进行传参数，实际上也改变了参数本身的内容。</p> <p>在Julia中，如果一个函数名以！结尾，表明它会改变输入参数的内容。而不带！的函数名，只是会有返回值，不会改变输入参数的值。</p> <ul> <li><p><strong>函数并不一定有名字</strong></p> </ul> <p>可以认为，没有名字的函数可以使用一次，然后没法再次唤醒它。 在一些语言中，没有名字的函数可以使用lambda表达式进行定义。比如scheme,</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >lambda</span></span> (x) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> x <span class=hljs-number >2</span>))</code></pre>
<p>又比如python，</p>
<pre><code class="python hljs"><span class=hljs-keyword >lambda</span> x: x+<span class=hljs-number >2</span></code></pre>
<p>在javascript中则可以这样定义函数，</p>
<pre><code class="javascript hljs">x-&gt; x+<span class=hljs-number >2</span></code></pre>
<p>甚至，C&#43;&#43;，</p>
<pre><code class="cpp hljs">[](<span class=hljs-type >float</span> x)-&gt;<span class=hljs-type >float</span>{<span class=hljs-keyword >return</span> x+<span class=hljs-number >2</span>;};</code></pre>
<p>没有名字有什么用呢？其实有的，比如在python中，可以使用map来调用一次，</p>
<pre><code class="python hljs"><span class=hljs-built_in >map</span>(<span class=hljs-keyword >lambda</span> x: x+<span class=hljs-number >2</span>, [<span class=hljs-number >1</span>,<span class=hljs-number >3</span>,<span class=hljs-number >5</span>,<span class=hljs-number >7</span>])</code></pre>
<p>比如scheme这样调用，</p>
<pre><code class="scheme hljs">((<span class=hljs-name ><span class=hljs-built_in >lambda</span></span> (x) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> x <span class=hljs-number >2</span>)) <span class=hljs-number >4</span>)</code></pre>
<p>当然，javacript和c&#43;&#43;也可以类似的对匿名函数进行使用。</p>
<p>但是匿名函数使用一次，没法在想用的时候再次召唤出来。所以我们可以给它取个名字，就好比给锅安装了个柄，可以通过柄把锅抓住。</p>
<p>如下的C&#43;&#43;把匿名函数取了个名字addfunciton，并调用它，</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >auto</span> addfunction=[](<span class=hljs-type >float</span> x)-&gt;<span class=hljs-type >float</span>{<span class=hljs-keyword >return</span> x+<span class=hljs-number >2</span>;};
<span class=hljs-built_in >addfunction</span>(<span class=hljs-number >3</span>)</code></pre>
<p>如下的python代码把匿名函数取了个名字add2，并调用它</p>
<pre><code class="python hljs">add2 = <span class=hljs-keyword >lambda</span> x: x+<span class=hljs-number >2</span>
add2(<span class=hljs-number >3</span>)</code></pre>
<p>如下的scheme代码把匿名函数取了个名字add2，并调用它</p>
<pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> add2 (<span class=hljs-name ><span class=hljs-built_in >lambda</span></span> (x) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> x <span class=hljs-number >2</span>)))  (<span class=hljs-name >add2</span> <span class=hljs-number >3</span>)</code></pre>
<p>给函数取名，是因为我们要方便我们在需要的时候召唤它。</p>
<ul>
<li><p><strong>加减乘除本质就是函数</strong></p>

</ul>
<p>3&#43;4对应的scheme表达可以写成&#40;&#43; 3 4&#41;, 这里&#43;其实就是一个函数。所以说，加减乘除本质上就是函数。 我们甚至可以在julia的repl中这样操作：把 &#43; 运算符（本质就是&#43;函数）赋值给f，通过f&#40;2,3&#41;来调用，</p>
<pre><code class="julia hljs">f = +
f(<span class=hljs-number >2</span>,<span class=hljs-number >3</span>)</code></pre>
<p>我们使用“3&#43;2”这样的表达式时，我们称呼这是中缀表达式。而如果我们按照scheme的写法，&#40;&#43; 3 2&#41;时，采用的是前缀表达。</p>
<p>可见，运算符就是个函数。</p>
<p>c&#43;&#43;可以进行运算符重载，即可以重定义或重载大部分 C&#43;&#43; 内置的运算符。这样，就能使用自定义类型的运算符。重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<p>python呢，对一个类而言，如果你重新定义了<code>__add__</code>函数，就是重载了&#43;运算符。</p>
<p>而julia呢，用的是多重分发，你针对你的类型增加了Base.&#40;&#43;&#41;函数，就是对你的这个类型定义了&#43;运算符。</p>
<p>实际上，我们还可以走得更远一点，仍然在julia的repl中，</p>
<pre><code class="julia hljs">abc = Meta.parse(<span class=hljs-string >&quot;3+2&quot;</span>)
Meta.show_sexpr(abc)</code></pre>
<p>来看看内部的代码表示。我们可以发现，julia底层就是类似于scheme的表达。可以粗浅地认为julia是一个高级版的scheme。</p>
<p>核心本质，加减乘除运算符本质都是函数。采用前缀表达式，尽管像四则混合运算这样的情况对眼睛不友好，可是使用函数表达方式，很用户友好。</p>
<ul>
<li><p><strong>主函数并不是必须的，但运行程序必须有个入口</strong></p>

</ul>
<p>我们在学习c或者Fortran的时候，总是从main函数开始的，这其实是编译器的要求。</p>
<p>在julia语言中，如果你用<code>julia foo.jl</code>启动你的脚本foo.jl, 那这个foo.jl脚本本身就是你要执行的程序，大逻辑上会按照这个脚本内的内容顺序执行。当然在这个大逻辑框架内部，你可以调用别的函数，或者有循环，有分支等等。</p>
<p>在python语言中，如果我们使用pycharm来开始运行调试，会让你指定调试入口，就是指出从哪个文件开始运行。大逻辑上会按照你的py脚本内的内容顺序执行。但是如果你的py文件前面只是定义了符号、变量、函数等等，实际上是啥也没干。而如果在你的py脚本最后存在<code>if __name__&#61;&#61;&quot;__main__&quot;</code>语句，则是以本脚本启动的时候，程序入口所在，</p>
<pre><code class="python hljs"><span class=hljs-keyword >def</span> <span class="hljs-title function_">hello</span>():
    <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;hello&quot;</span>)
<span class=hljs-keyword >if</span> __name__==<span class=hljs-string >&quot;__main__&quot;</span>
    hello()</code></pre>
<p>而java呢，它是把一个类写成一个.java文件，编译之后，一个.java文件就对应一个.class文件，把一些.class文件打包到一块呢就成了.jar文件。编译的时候，通过Manifest.txt里Main-class指定入口。</p>
<p>对于c，我们甚至可以开脑洞想一想，用lambda定义一个匿名函数，然后把它命名为main，然后编译运行它，（我没有实测过是否可行啊），</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >auto</span> main=[]()-&gt;<span class=hljs-type >int</span> { <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;hello world&quot;</span>);<span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;};</code></pre>
<p>总之，主函数并不是必须的，但运行程序必须有个入口。</p>
<ul>
<li><p><strong>提供给函数的参数需要按约定好的要求</strong></p>

</ul>
<p>那我们现在来说说函数的参数。函数的参数就是一种约定，你要我处理一件事，你就得按照我的要求来提供材料。你要发快递，那么，收件人地址、收件人姓名、收件人电话，这就是我提出的要求。函数也一样。你要我计算一个浮点数x对应的sin&#40;x&#41;的值，那你就得按float给我提供这个参数x。</p>
<p>因为数据有类型，所以函数对参数可以表达类型要求。返回值对应的也有类型。</p>
<p>而有些语言是动态类型的，就是不显示的声明类型，运行到这里的时候，是什么类型，就按什么类型给你处理，比如</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> f(x)
    x + <span class=hljs-number >2</span>
<span class=hljs-keyword >end</span></code></pre>
<p>python、julia等是动态类型的。而c/c&#43;&#43;、Fortran等语言是静态类型的。</p>
<p>我们在寄件的时候，可以问你要三个参数，收件人地址、收件人姓名、收件人电话，如果我约定的是一个结构化的数据（比如含有上述三个信息的表格），你就可以直接一次给我整个表格。同样的，如果我要你给交一系列的打印文字，你可以一页一页的交给我，也可以装订成若干册交给我。装订（打包）成册，就是以结构化的信息给我提供了所需信息。问题是，你给我提供的信息得按我的要求来。</p>
<p>函数也一样，可以以独立的一个个的浮点数来传递我所需的参数，也可以打包成结构体。取决于定义函数的时候所用的形式，就是取决于函数的要求。甚至，我们曾看到，在Fortran的一个实际程序中，对一个太阳能集热板组件，把所有的输入参数存入一个数组xin，所有的输出参数存入一个数组xout，然后调用对应的subroutine。</p>
<pre><code class="julia hljs">subroutine solarcollector(xin,xout)
    ...
<span class=hljs-keyword >end</span></code></pre>
<p>总之，一句话，提供给函数的参数需要按约定好的要求，这个约定和要求是在定义函数的时候决定的。</p>
<p>因为计算机是机械化的信息处理，所以最初只能按确定的形式接受。但是人们通过一些办法实现了对人更友好，就可以处理一页一页交过来我能处理，一册一册叫过来我也能处理。某种意义上讲，这就是一种多态。</p>
<p>Julia语言中通过对同一个函数名写不同的处理方法来实现。而c&#43;&#43;通过参数形式的不同实现不同的具体的函数，来处理多态问题。这个我们暂时不去深究。</p>
<ul>
<li><p><strong>函数可以封装成库给别人调用，有动态库，有静态库</strong></p>

</ul>
<p>我们写函数的本质是把具有一定功能性代码整合起来，可以重复的使用。至于函数内部的实现，你可以认为就是一个黑箱。但是我得告诉你我有什么功能。就像快递收发点一样，怎么运输的你不用管，但是我得有个目录告诉你有些什么选择和对应的收费标准。</p>
<p>c语言中，stdio等库就是这么个情况，把很多有用的函数封装在一起，成为一个库（静态和动态我们等会儿再说），库里有什么则通过stdio.h这个文件告诉你，同时stdio.h也告诉你了要以什么样的参数方式调用。</p>
<p>我们如果使用CLion，创建一个新项目，选择c library，可以产生如下的两个文件，library.h和library.cpp</p>
<pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-keyword >ifndef</span> TESTD_LIBRARY_H</span>
<span class=hljs-meta >#<span class=hljs-keyword >define</span> TESTD_LIBRARY_H</span>

<span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >hello</span><span class=hljs-params >()</span></span>;

<span class=hljs-meta >#<span class=hljs-keyword >endif</span> <span class=hljs-comment >//TESTD_LIBRARY_H</span></span></code></pre>
<pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&quot;library.h&quot;</span></span>

<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;iostream&gt;</span></span>

<span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >hello</span><span class=hljs-params >()</span> </span>{
    std::cout &lt;&lt; <span class=hljs-string >&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;
}</code></pre>
<p>CLion为了方便我们使用，还产生了项目的 CMakelists.txt文件。</p>
<pre><code class="cmake hljs"><span class=hljs-keyword >cmake_minimum_required</span>(VERSION <span class=hljs-number >3.20</span>)
<span class=hljs-keyword >project</span>(testd)

<span class=hljs-keyword >set</span>(CMAKE_CXX_STANDARD <span class=hljs-number >14</span>)

<span class=hljs-keyword >add_library</span>(testd library.cpp)</code></pre>
<p>在Clion中，我们build一下，就产生了对应的libtestd.a文件。</p>
<p>如果我们当初创建c library的时候，选择的是动态链接库，则产生的CMakelists.txt略有不同，</p>
<pre><code class="julia hljs">add_library(testd SHARED library.cpp)</code></pre>
<p>我们build之后呢，产生的则是libtestd.dll文件。</p>
<p>这里我们首先解释一下动态链接库和静态链接库。</p>
<p>从上面的描述我们可以发现，人们可以把一些函数封装成库，提供给用户服务。c语言就有很多这样的库，你写的时候，就可以调用c语言自带的这些库函数。编译的时候，你的c语言源代码会编译成.o文件，但是要做成exe文件，还需要把库里所有要用到的那些函数代码嵌入进来，这种方式就是静态的链接到了你的exe文件中。提供的这些库，就称呼为静态链接库。</p>
<p>而如果某些函数使用率非常的高，或者你自己脑回路清奇，或者乐意，你也可以把那些用到的函数不嵌入进来，只是告诉你的exe程序，需要用到某个库中的某个函数，在运行的时候才加载那个库，调用库里的函数。这样的方式就是动态链接库。</p>
<p>在windows下，静态链接库一般是lib为后缀名，动态链接库一般是dll为后缀名。</p>
<p>在linux下，静态链接库一般是a为后缀名，动态链接库一般是so为后缀名。</p>
<p>在mac os x 下，动态链接库一般是dylib为后缀名。</p>
<p>如果我们有linux系统，我们可以在终端下使用<code>ldd ls</code>，来查看ls这个命令运行的时候要用到的动态链接库。如果找不到某个so文件，那么你的程序就无法执行。</p>
<p>那么系统会到哪里去找这些动态链接库和静态链接库呢。先说Linux下的情况。静态的，是编译时要嵌入的，所以如果使用gcc命令行编译，<code>gcc -I</code>的部分<code>-I</code>后面指定头文件搜索目录，<code>-L</code>指定加载的库所在地。动态的，编译的时候，也是需要<code>-I</code> <code>-L</code>这样的选项指定。还有就是会去系统的两个变量所描述的目录去找。一个是<code>INCLUDE_PATH</code>，一个是<code>LD_LIBRARY_PATH</code>。而这两个变量系统会维护，你自己也可以对它进行改变。windows下类似，但往往还在当前目录去搜索。如果使用visual studio系列的集成开发环境编程，则在配置中，可以指定使用哪些静态动态链接库，以及它们所在的位置。</p>
<p>静态链接的好说，函数都嵌入到你的exe中了，拷贝到别的电脑上就能用。它的缺点是可执行文件相对较大。动态链接库，除了拷贝你的exe文件过去之外，还得确保在目标机子上，相应的动态链接库也能被找到。</p>
<ul>
<li><p><strong>函数能跨语言调用</strong></p>

</ul>
<p>我们通过c语言写函数，编译成动态链接库（dll或者so），它能被python调用，比如以下是一个软件的程序片段（https://github.com/NREL/REopt_API/blob/master/reo/src/sscapi.py），</p>
<pre><code class="python hljs"><span class=hljs-keyword >class</span> <span class="hljs-title class_">PySSC</span>:

    <span class=hljs-keyword >def</span> <span class="hljs-title function_">__init__</span>(<span class=hljs-params >self</span>):
        <span class=hljs-keyword >if</span> sys.platform == <span class=hljs-string >&#x27;win32&#x27;</span> <span class=hljs-keyword >or</span> sys.platform == <span class=hljs-string >&#x27;cygwin&#x27;</span>:
            <span class=hljs-comment ># nlaws 201201 Windows is no longer supported (by celery) but is cygwin supported?</span>
            self.pdll = CDLL(<span class=hljs-string >&quot;ssc.dll&quot;</span>)
        <span class=hljs-keyword >elif</span> sys.platform == <span class=hljs-string >&#x27;darwin&#x27;</span>:
            <span class=hljs-comment ># <span class=hljs-doctag >NOTE:</span> the path of this file must be in DYLD_LIBRARY_PATH</span>
            self.pdll = CDLL(<span class=hljs-string >&quot;ssc.dylib&quot;</span>)
        <span class=hljs-keyword >elif</span> sys.platform == <span class=hljs-string >&#x27;linux2&#x27;</span> <span class=hljs-keyword >or</span> sys.platform == <span class=hljs-string >&#x27;linux&#x27;</span>:
            <span class=hljs-comment ># <span class=hljs-doctag >NOTE:</span> the path of this file must be in LD_LIBRARY_PATH</span>
            self.pdll = CDLL(<span class=hljs-string >&#x27;ssc.so&#x27;</span>)
        <span class=hljs-keyword >else</span>:
            <span class=hljs-built_in >print</span>(<span class=hljs-string >&quot;Platform of type {} not supported for wind analyses.&quot;</span>.<span class=hljs-built_in >format</span>(sys.platform))
    ...

    <span class=hljs-keyword >def</span> <span class="hljs-title function_">version</span>(<span class=hljs-params >self</span>):
        self.pdll.ssc_version.restype = c_int
        <span class=hljs-keyword >return</span> self.pdll.ssc_version()</code></pre>
<p>它首先根据你系统的不同，加载了对应的动态链接库，然后定义了version函数。你调用这个python版的version函数时，本质是执行了动态链接库中的ssc_version&#40;&#41;函数。</p>
<p>dll也可以被julia调用。对dll，Julia 提供简洁且高效的调用方式。Julia 的哲学是 no boilerplate： Julia 可以直接调用 C/Fortran 的函数，不需要任何&quot;胶水&quot;代码，代码生成或其它编译过程。上述特性可以仅仅通过调用 ccall 实现，它的语法看起来就像是普通的函数调用。</p>
<p>被调用的代码必须是一个共享库（.so, .dylib, .dll）。大多数 C 和 Fortran 库都已经是以共享库的形式发布的，但在用 GCC 或 Clang 编译自己的代码时，需要添加 -shared 和 -fPIC 编译器选项。</p>
<p>可以通过&#40;:function, &quot;library&quot;&#41; 或 &#40;&quot;function&quot;, &quot;library&quot;&#41; 这两种形式来索引库中的函数，其中 function 是函数名，library 是库名。（特定平台/操作系统的）加载路径中可用的共享库将按名称解析。 也可以指定库的完整路径。</p>
<p>一个典型的例子如下：</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Compat
<span class=hljs-keyword >const</span> coolproplibrary = joinpath(<span class=hljs-meta >@__DIR__</span>, <span class=hljs-string >&quot;./CoolProp.dll&quot;</span>)

<span class=hljs-keyword >function</span> PropsSI(fluid::<span class=hljs-built_in >AbstractString</span>, output::<span class=hljs-built_in >AbstractString</span>)
    val = <span class=hljs-keyword >ccall</span>( (:Props1SI, coolproplibrary), <span class=hljs-built_in >Cdouble</span>, (<span class=hljs-built_in >Cstring</span>, <span class=hljs-built_in >Cstring</span>), fluid, output)
    <span class=hljs-keyword >if</span> val == <span class=hljs-literal >Inf</span>
        error(<span class=hljs-string >&quot;CoolProp: &quot;</span>, get_global_param_string(<span class=hljs-string >&quot;errstring&quot;</span>))
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> val
<span class=hljs-keyword >end</span></code></pre>
<p>就是通过coolproplibrary标记这个dll文件，然后写一个PropsSI函数，内部调用Props1SI进行处理。</p>
<p>在fortran与c混合编程中，过去进行混合语言编程是比较麻烦的，现在随着Fortran标准的进一步发展，已经很简单了，使用<code>ISO_C_BINDING</code>，就好了，下面是<a href="https://github.com/OP-DSL/OPS">https://github.com/OP-DSL/OPS</a>中的代码片段，</p>
<pre><code class="julia hljs"><span class=hljs-keyword >module</span> OPS_Fortran_Declarations

  use, intrinsic :: ISO_C_BINDING
  ...
  integer(c_int) :: OPS_READ = <span class=hljs-number >1</span>
  integer(c_int) :: OPS_WRITE = <span class=hljs-number >2</span>
  integer(c_int) :: OPS_RW = <span class=hljs-number >3</span>
  integer(c_int) :: OPS_INC = <span class=hljs-number >4</span>
  integer(c_int) :: OPS_MIN = <span class=hljs-number >5</span>
  integer(c_int) :: OPS_MAX = <span class=hljs-number >6</span>
  ...
  subroutine ops_reduction_result_real_8 (reduction_handle, var)
    use, intrinsic :: ISO_C_BINDING
    type(ops_reduction) :: reduction_handle
    real(<span class=hljs-number >8</span>), dimension(:), target :: var

    call ops_reduction_result_c (reduction_handle%reductionCptr, reduction_handle%reductionPtr%size, c_loc(var))
  <span class=hljs-keyword >end</span> subroutine ops_reduction_result_real_8
  ...
<span class=hljs-keyword >end</span> <span class=hljs-keyword >module</span> OPS_Fortran_Declarations</code></pre>
<p>这段代码虽然不能直接就运行检查，但是启发我们，fortran和c互相调用，使用<code>ISO_C_BINDING</code>就很简单了。</p>
<p>小结一下，函数能跨语言调用，按照提供（要求）的方法就好。</p>
<ul>
<li><p><strong>可执行程序就是个函数，但是函数参数的给定方式是命令行参数</strong></p>

</ul>
<p>在linux下的shell下，我们知道命令有很多选项，比如<code>ls</code>，可以在后面加上选项和参数，比如<code>ls -l /usr/local</code>。</p>
<p>在windows下也一样，以<code>dir</code>这个命令为例，可以加上选项和参数，<code>dir /a c:\</code>，这里<code>/a</code>是选项，<code>c:\</code>是参数。</p>
<p>我们在<a href="https://github.com/wertarbyte/coreutils/blob/master/src/ls.c">https://github.com/wertarbyte/coreutils/blob/master/src/ls.c</a>看一下ls的源代码，</p>
<pre><code class="c hljs"><span class=hljs-type >int</span>
<span class="hljs-title function_">main</span> <span class=hljs-params >(<span class=hljs-type >int</span> argc, <span class=hljs-type >char</span> **argv)</span>
{
    ...
    initialize_main (&amp;argc, &amp;argv);
    ...
    i = decode_switches (argc, argv);
    ...
}</code></pre>
<p>这里的argc和argv就是参数（argument, arg）的数量&#40;count,c&#41;和值（value，v）。而decode_switches就是解析出来参数的值，然后根据参数的值确定函数下一步的行为。</p>
<p>有的可能会单独写一个函数来处理命令行参数，类似于这样,</p>
<pre><code class="julia hljs"><span class=hljs-comment >#ifdef TRILIBRARY</span>
  parsecommandline(<span class=hljs-number >1</span>, &amp;triswitches, &amp;b);
<span class=hljs-comment >#else /* not TRILIBRARY */</span>
  parsecommandline(argc, argv, &amp;b);
<span class=hljs-comment >#endif /* not TRILIBRARY */</span>
  m.steinerleft = b.steiner;</code></pre>
<p>Fortran也类似，对于Fortran2003及其之后，使用<code>GET_COMMAND_ARGUMENT</code>来获取参数</p>
<pre><code class="julia hljs">PROGRAM test_get_command_argument
INTEGER :: i,n
CHARACTER(len=<span class=hljs-number >32</span>) :: arg
          
i = <span class=hljs-number >1</span>
DO
CALL get_command_argument(i, arg)
IF (LEN_TRIM(arg) == <span class=hljs-number >0</span>) EXIT
READ(arg,&#x27;(I3)&#x27;) n
WRITE (*,*) n*n
i = i+<span class=hljs-number >1</span>
END DO
 
END PROGRAM</code></pre>
<p>比如编译后的可执行程序叫testComArg，在终端中输入： <code>./testComArg 2 3</code> 将得到:</p>
<pre><code class="julia hljs"><span class=hljs-number >4</span>
<span class=hljs-number >9</span></code></pre>
<p>当然python什么的，不外如是。</p>
<p>所以说，可执行程序就是个函数，但是函数参数的给定方式是命令行参数。</p>
<ul>
<li><p><strong>程序执行时的环境变量也会影响函数的行为</strong></p>

</ul>
<p>还需要说的就是，系统运行的时候存在一些平时我们没有注意的一些“变量”，通常称为环境变量。包括，用户名是啥啊，用的shell是啥啊，当前目录是上啊，等等。在命令行提示符下输入<code>env</code>回车，你就能看到很多的环境变量。通俗点说呢，就是个变量表。有变量名，有值。linux下也是如此。</p>
<p>某些函数在运行时会询问这个参数表（环境变量表）中某些参数的值，从而确定自己的行为。</p>
<p>比如我们的julia，我们执行<code>versioninfo&#40;&#41;</code>的时候，可以看到<code>JULIA_PKG_SERVER &#61; https://mirrors.tuna.tsinghua.edu.cn/julia</code>，这样，我在进入Pkg模式，添加软件包时，它就会去<code>JULIA_PKG_SERVER</code>标记的镜像站点下载。</p>
<pre><code class="julia hljs">julia&gt; versioninfo()
Julia Version <span class=hljs-number >1.7</span><span class=hljs-number >.2</span>
Commit bf53498635 (<span class=hljs-number >2022</span>-<span class=hljs-number >02</span>-<span class=hljs-number >06</span> <span class=hljs-number >15</span>:<span class=hljs-number >21</span> UTC)
Platform Info:
  OS: Windows (x86_64-w64-mingw32)
  CPU: Intel(R) Core(TM) i7-<span class=hljs-number >7700</span> CPU @ <span class=hljs-number >3.60</span>GHz
  WORD_SIZE: <span class=hljs-number >64</span>
  LIBM: libopenlibm
  LLVM: libLLVM-<span class=hljs-number >12.0</span><span class=hljs-number >.1</span> (ORCJIT, skylake)
Environment:
  JULIA_PKG_SERVER = https://mirrors.tuna.tsinghua.edu.cn/julia
julia&gt;</code></pre>
<p>当然的，是这些函数内部要求了要去查某个或者某些环境变量的值，并使用了它。</p>
<p>小结来说，程序执行时的环境变量也会影响函数的行为。</p>
<ul>
<li><p><strong>函数运行时的“环境”与闭包</strong></p>

</ul>
<p>函数调用，形象来讲就是做了个梦，被调用的函数中再调用函数，就是梦中做梦。（你看过电影盗梦空间吗？）</p>
<p>打过游戏的同学可能也有体会，函数调用就是玩游戏时打开了一个门，屏幕黑了一下或者白了一下，进入了一个新的情景，在这个新的情景中还可能会继续下去打开新的密室。</p>
<p>可是你在梦中所携带的工具是进入梦境就给你了的，就是“变量-值”表。打游戏的技能集，就相当于是若干个变量-值对。</p>
<p>我们从一个游戏情景返回到原来的情景，就相当于是函数调用返回。返回回来，情节就接着演啊。这就是进入一层梦境的时候，就把所有的技能集加在最前面，返回的时候就去掉最前面加上去的那些。栈嘛，就是栈。</p>
<p>操作系统，或者说编译器，总之就是底层的那些，在调用的时候，实际上是把函数入口和“环境”（不只是环境变量，还包括你的参数集，一起组成环境）当成一个整体开始进入梦境。当成一个整体就是构成一个结构体，就是当做一个闭包。</p>
<p>关于闭包，更多的可以看看这个，<a href="http://www.yinwang.org/blog-cn/2013/03/26/lisp-dead-alive">Lisp 已死，Lisp 万岁！</a> 或者yuziwen的<a href="https://yuziwen.github.io/pl-tutorial-1.html">PL教程 第一章 人和机器</a>, “习题：找规律”之前的那一部分内容。</p>
<ul>
<li><p><strong>事件驱动与死循环，服务程序</strong></p>

</ul>
<p>我们初学编程的时候，老师给我们说，不要写死循环。是的，那时候电脑就给你个黑屏，死循环无法退出，机子就只好重启了。</p>
<p>可是，真的不能写死循环吗？以下来自<a href="https://github.com/APMonitor/arduino/blob/master/0_Test_Device/Python/tclab_v2/tclab_v2.ino">https://github.com/APMonitor/arduino/blob/master/0_Test_Device/Python/tclab_v2/tclab_v2.ino</a>，是一个温度控制小实验板上的程序，arduino上运行的。复制这么长的代码不利于阅读，但是为了完整性，我们还是都贴过来。</p>
<pre><code class="julia hljs"><span class=hljs-comment >#include &quot;Arduino.h&quot;</span>

// determine board type
<span class=hljs-comment >#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)</span>
  <span class=hljs-built_in >String</span> boardType = <span class=hljs-string >&quot;Arduino Uno&quot;</span>;
<span class=hljs-comment >#elif defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__)</span>
  <span class=hljs-built_in >String</span> boardType = <span class=hljs-string >&quot;Arduino Leonardo/Micro&quot;</span>;
<span class=hljs-comment >#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)</span>
  <span class=hljs-built_in >String</span> boardType = <span class=hljs-string >&quot;Arduino Mega&quot;</span>;
<span class=hljs-comment >#else </span>
  <span class=hljs-built_in >String</span> boardType = <span class=hljs-string >&quot;Unknown board&quot;</span>;
<span class=hljs-comment >#endif</span>

// Enable debugging output
<span class=hljs-keyword >const</span> bool DEBUG = <span class=hljs-literal >false</span>;

// constants
<span class=hljs-keyword >const</span> <span class=hljs-built_in >String</span> vers = <span class=hljs-string >&quot;2.0.1&quot;</span>;   // version of this firmware
<span class=hljs-keyword >const</span> long baud = <span class=hljs-number >115200</span>;      // serial baud rate
<span class=hljs-keyword >const</span> char sp = <span class=hljs-string >&#x27; &#x27;</span>;           // command separator
<span class=hljs-keyword >const</span> char nl = &#x27;\n&#x27;;          // command terminator

// pin numbers corresponding to signals on the TC Lab Shield
<span class=hljs-keyword >const</span> int pinT1   = <span class=hljs-number >0</span>;         // T1
<span class=hljs-keyword >const</span> int pinT2   = <span class=hljs-number >2</span>;         // T2
<span class=hljs-keyword >const</span> int pinQ1   = <span class=hljs-number >3</span>;         // Q1
<span class=hljs-keyword >const</span> int pinQ2   = <span class=hljs-number >5</span>;         // Q2
<span class=hljs-keyword >const</span> int pinLED1 = <span class=hljs-number >9</span>;         // LED1

// temperature alarm limits
<span class=hljs-keyword >const</span> int limT1   = <span class=hljs-number >50</span>;       // T1 high alarm (°C)
<span class=hljs-keyword >const</span> int limT2   = <span class=hljs-number >50</span>;       // T2 high alarm (°C)

// LED1 levels
<span class=hljs-keyword >const</span> int hiLED   =  <span class=hljs-number >60</span>;       // hi LED
<span class=hljs-keyword >const</span> int loLED   = hiLED/<span class=hljs-number >16</span>;  // lo LED

// <span class=hljs-keyword >global</span> variables
char Buffer[<span class=hljs-number >64</span>];               // buffer <span class=hljs-keyword >for</span> parsing serial input
int buffer_index = <span class=hljs-number >0</span>;          // index <span class=hljs-keyword >for</span> Buffer
<span class=hljs-built_in >String</span> cmd;                    // command
float val;                     // command value
int ledStatus;                 // <span class=hljs-number >1</span>: loLED
                               // <span class=hljs-number >2</span>: hiLED
                               // <span class=hljs-number >3</span>: loLED blink
                               // <span class=hljs-number >4</span>: hiLED blink
long ledTimeout = <span class=hljs-number >0</span>;           // when to <span class=hljs-keyword >return</span> LED to normal operation
float LED = <span class=hljs-number >100</span>;               // LED override brightness
float P1 = <span class=hljs-number >200</span>;                // heater <span class=hljs-number >1</span> power limit <span class=hljs-keyword >in</span> units of pwm. Range <span class=hljs-number >0</span> to <span class=hljs-number >255</span>
float P2 = <span class=hljs-number >100</span>;                // heater <span class=hljs-number >2</span> power limit <span class=hljs-keyword >in</span> units <span class=hljs-keyword >in</span> pwm, range <span class=hljs-number >0</span> to <span class=hljs-number >255</span>
float Q1 = <span class=hljs-number >0</span>;                  // last value written to heater <span class=hljs-number >1</span> <span class=hljs-keyword >in</span> units of percent
float Q2 = <span class=hljs-number >0</span>;                  // last value written to heater <span class=hljs-number >2</span> <span class=hljs-keyword >in</span> units of percent
int alarmStatus;               // hi temperature alarm status
boolean newData = <span class=hljs-literal >false</span>;       // boolean flag indicating new command
int n =  <span class=hljs-number >10</span>;                   // number of samples <span class=hljs-keyword >for</span> each temperature measurement


void readCommand() {
  <span class=hljs-keyword >while</span> (Serial &amp;&amp; (Serial.available() &gt; <span class=hljs-number >0</span>) &amp;&amp; (newData == <span class=hljs-literal >false</span>)) {
    int byte = Serial.read();
    <span class=hljs-keyword >if</span> ((byte != &#x27;\r&#x27;) &amp;&amp; (byte != nl) &amp;&amp; (buffer_index &lt; <span class=hljs-number >64</span>)) {
      Buffer[buffer_index] = byte;
      buffer_index++;
    }
    <span class=hljs-keyword >else</span> {
      newData = <span class=hljs-literal >true</span>;
    }
  }   
}

// <span class=hljs-keyword >for</span> debugging with the serial monitor <span class=hljs-keyword >in</span> Arduino IDE
void echoCommand() {
  <span class=hljs-keyword >if</span> (newData) {
    Serial.write(<span class=hljs-string >&quot;Received Command: &quot;</span>);
    Serial.write(Buffer, buffer_index);
    Serial.write(nl);
    Serial.flush();
  }
}

// <span class=hljs-keyword >return</span> average  of n reads of thermister temperature <span class=hljs-keyword >in</span> °C
inline float readTemperature(int pin) {
  float degC = <span class=hljs-number >0.0</span>;
  <span class=hljs-keyword >for</span> (int i = <span class=hljs-number >0</span>; i &lt; n; i++) {
    degC += analogRead(pin) * <span class=hljs-number >0.322265625</span> - <span class=hljs-number >50.0</span>;    // use <span class=hljs-keyword >for</span> <span class=hljs-number >3.3</span>v AREF
    //degC += analogRead(pin) * <span class=hljs-number >0.170898438</span> - <span class=hljs-number >50.0</span>;  // use <span class=hljs-keyword >for</span> <span class=hljs-number >1.75</span>v AREF
  }
  <span class=hljs-keyword >return</span> degC / float(n);
}

void parseCommand(void) {
  <span class=hljs-keyword >if</span> (newData) {
    <span class=hljs-built_in >String</span> read_ = <span class=hljs-built_in >String</span>(Buffer);

    // separate command from associated data
    int idx = read_.indexOf(sp);
    cmd = read_.substring(<span class=hljs-number >0</span>, idx);
    cmd.trim();
    cmd.toUpperCase();

    // extract data. toFloat() returns <span class=hljs-number >0</span> on error
    <span class=hljs-built_in >String</span> data = read_.substring(idx + <span class=hljs-number >1</span>);
    data.trim();
    val = data.toFloat();

    // reset parameter <span class=hljs-keyword >for</span> next command
    memset(Buffer, <span class=hljs-number >0</span>, sizeof(Buffer));
    buffer_index = <span class=hljs-number >0</span>;
    newData = <span class=hljs-literal >false</span>;
  }
}

void sendResponse(<span class=hljs-built_in >String</span> msg) {
  Serial.println(msg);
}

void sendFloatResponse(float val) {
  Serial.println(<span class=hljs-built_in >String</span>(val, <span class=hljs-number >3</span>));
}

void sendBinaryResponse(float val) {
  byte *b = (byte*)&amp;val;
  Serial.write(b, <span class=hljs-number >4</span>);  
}

void dispatchCommand(void) {
  <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;A&quot;</span>) {
    setHeater1(<span class=hljs-number >0</span>);
    setHeater2(<span class=hljs-number >0</span>);
    sendResponse(<span class=hljs-string >&quot;Start&quot;</span>);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;LED&quot;</span>) {
    ledTimeout = millis() + <span class=hljs-number >10000</span>;
    LED = max(<span class=hljs-number >0</span>, min(<span class=hljs-number >100</span>, val));
    sendResponse(<span class=hljs-built_in >String</span>(LED));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;P1&quot;</span>) {
    P1 = max(<span class=hljs-number >0</span>, min(<span class=hljs-number >255</span>, val));
    sendResponse(<span class=hljs-built_in >String</span>(P1));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;P2&quot;</span>) {
    P2 = max(<span class=hljs-number >0</span>, min(<span class=hljs-number >255</span>, val));
    sendResponse(<span class=hljs-built_in >String</span>(P2));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;Q1&quot;</span>) {
    setHeater1(val);
    sendFloatResponse(Q1);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;Q1B&quot;</span>) {
    setHeater1(val);
    sendBinaryResponse(Q1);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;Q2&quot;</span>) {
    setHeater2(val);
    sendFloatResponse(Q2);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;Q2B&quot;</span>) {
    setHeater1(val);
    sendBinaryResponse(Q2);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;R1&quot;</span>) {
    sendFloatResponse(Q1);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;R2&quot;</span>) {
    sendFloatResponse(Q2);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;SCAN&quot;</span>) {
    sendFloatResponse(readTemperature(pinT1));
    sendFloatResponse(readTemperature(pinT2));
    sendFloatResponse(Q1);
    sendFloatResponse(Q2);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;T1&quot;</span>) {
    sendFloatResponse(readTemperature(pinT1));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;T1B&quot;</span>) {
    sendBinaryResponse(readTemperature(pinT1));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;T2&quot;</span>) {
    sendFloatResponse(readTemperature(pinT2));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;T2B&quot;</span>) {
    sendBinaryResponse(readTemperature(pinT2));
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;VER&quot;</span>) {
    sendResponse(<span class=hljs-string >&quot;TCLab Firmware &quot;</span> + vers + <span class=hljs-string >&quot; &quot;</span> + boardType);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd == <span class=hljs-string >&quot;X&quot;</span>) {
    setHeater1(<span class=hljs-number >0</span>);
    setHeater2(<span class=hljs-number >0</span>);
    sendResponse(<span class=hljs-string >&quot;Stop&quot;</span>);
  }
  <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> (cmd.length() &gt; <span class=hljs-number >0</span>) {
    setHeater1(<span class=hljs-number >0</span>);
    setHeater2(<span class=hljs-number >0</span>);
    sendResponse(cmd);
  }
  Serial.flush();
  cmd = <span class=hljs-string >&quot;&quot;</span>;
}

void checkAlarm(void) {
  <span class=hljs-keyword >if</span> ((readTemperature(pinT1) &gt; limT1) or (readTemperature(pinT2) &gt; limT2)) {
    alarmStatus = <span class=hljs-number >1</span>;
  }
  <span class=hljs-keyword >else</span> {
    alarmStatus = <span class=hljs-number >0</span>;
  }
}

void updateStatus(void) {
  // determine led status
  ledStatus = <span class=hljs-number >1</span>;
  <span class=hljs-keyword >if</span> ((Q1 &gt; <span class=hljs-number >0</span>) or (Q2 &gt; <span class=hljs-number >0</span>)) {
    ledStatus = <span class=hljs-number >2</span>;
  }
  <span class=hljs-keyword >if</span> (alarmStatus &gt; <span class=hljs-number >0</span>) {
    ledStatus += <span class=hljs-number >2</span>;
  }
  // update led depending on ledStatus
  <span class=hljs-keyword >if</span> (millis() &lt; ledTimeout) {        // override led operation
    analogWrite(pinLED1, LED);
  }
  <span class=hljs-keyword >else</span> {
    switch (ledStatus) {
      case <span class=hljs-number >1</span>:  // normal operation, heaters off
        analogWrite(pinLED1, loLED);
        <span class=hljs-keyword >break</span>;
      case <span class=hljs-number >2</span>:  // normal operation, heater on
        analogWrite(pinLED1, hiLED);
        <span class=hljs-keyword >break</span>;
      case <span class=hljs-number >3</span>:  // high temperature alarm, heater off
        <span class=hljs-keyword >if</span> ((millis() % <span class=hljs-number >2000</span>) &gt; <span class=hljs-number >1000</span>) {
          analogWrite(pinLED1, loLED);
        } <span class=hljs-keyword >else</span> {
          analogWrite(pinLED1, loLED/<span class=hljs-number >4</span>);
        }
        <span class=hljs-keyword >break</span>;
      case <span class=hljs-number >4</span>:  // high temperature alarm, heater on
        <span class=hljs-keyword >if</span> ((millis() % <span class=hljs-number >2000</span>) &gt; <span class=hljs-number >1000</span>) {
          analogWrite(pinLED1, hiLED);
        } <span class=hljs-keyword >else</span> {
          analogWrite(pinLED1, loLED);
        }
        <span class=hljs-keyword >break</span>;
    }   
  }
}

// set Heater <span class=hljs-number >1</span>
void setHeater1(float qval) {
  Q1 = max(<span class=hljs-number >0.</span>, min(qval, <span class=hljs-number >100.</span>));
  analogWrite(pinQ1, (Q1*P1)/<span class=hljs-number >100</span>);
}

// set Heater <span class=hljs-number >2</span>
void setHeater2(float qval) {
  Q2 = max(<span class=hljs-number >0.</span>, min(qval, <span class=hljs-number >100.</span>));
  analogWrite(pinQ2, (Q2*P2)/<span class=hljs-number >100</span>);
}

// arduino startup
void setup() {
  analogReference(EXTERNAL);
  <span class=hljs-keyword >while</span> (!Serial) {
    ; // wait <span class=hljs-keyword >for</span> serial port to connect.
  }
  Serial.<span class=hljs-keyword >begin</span>(baud);
  Serial.flush();
  setHeater1(<span class=hljs-number >0</span>);
  setHeater2(<span class=hljs-number >0</span>);
  ledTimeout = millis() + <span class=hljs-number >1000</span>;
}

// arduino main event loop
void loop() {
  readCommand();
  <span class=hljs-keyword >if</span> (DEBUG) echoCommand();
  parseCommand();
  dispatchCommand();
  checkAlarm();
  updateStatus();
}</code></pre>
<p>arduino是个单片机。最后一个函数，就相当于是主程序，就是个死循环。</p>
<pre><code class="julia hljs">void loop() {
  readCommand();
  <span class=hljs-keyword >if</span> (DEBUG) echoCommand();
  parseCommand();
  dispatchCommand();
  checkAlarm();
  updateStatus();
}</code></pre>
<p>显然，它就是在那里轮询，问你的命令是啥，然后解析命令，然后分发命令，然后返回状态，然后继续。</p>
<p>事件驱动程序也一样。图形化的窗口，实际上在不断的“询问”你的鼠标，你的键盘输入，基于此做出反应。直到你点了关闭按钮或者退出菜单。</p>
<p>服务器程序也一样。网页服务器程序就是在那里等待你的请求。专业的说法是监听，listen。</p>
<p>那为什么dos时代不让我们写死循环呢？因为没有任务管理器。没有上帝之手从外面关掉它。现在操作系统进步了，多任务的，都有办法。而且现在有些程序运行于沙箱模式，你可以随便玩，但是在外头可以销毁沙箱。</p>
<p>事实上，从函数调用的过程来说，操作系统就是最初的那个“根”函数。（类似于桌面上一堆窗口，你的desktop是哪个根窗口。）当然，操作系统不是一个函数组成的。比喻来说，大体如此。</p>
<ul>
<li><p>c&#43;&#43;的函数模板与泛型编程</p>

<li><p>动态类型语言与静态类型语言，及它们的互相靠拢</p>

</ul>
<p>python的类型提示</p>
<h2 id="模型与符号"><a href="#模型与符号" class=header-anchor >模型与符号</a></h2>
<ul>
<li><p>从符号到模型与parser</p>

<li><p>函数的调用就是用它来处理你的模型</p>

<li><p>模型处理与代码生成</p>

<li><p>编译器也是个函数</p>

</ul>
<p>好，现在是时候说说编译器了。编译器其实也是一个函数，它处理你的源代码（符号），首先是解析源代码（parse）获得这个符号代表的模型，然后对这个模型进行处理，最后以汇编或者机器码的形式输出到文件。</p>
<p>以gcc为例，通常我们的编译过程是这样的，</p>
<pre><code class="c hljs">gcc foo.c</code></pre>
<p>如果我们把这个过程放慢，那就是第一步编译到汇编，第二步从汇编到机器码，第三步进行连接，</p>
<pre><code class="julia hljs">gcc -S foo.c -o foo.asm
gcc foo.asm -o foo.o
gcc foo.o -o foo.exe</code></pre>
<p>从c语言代码到汇编代码，就是个解析符号、处理模型、输出模型的过程。</p>
<p>在机器码的基础上发展了汇编语言，在汇编语言的基础上发展了c这样的高级语言。</p>
<p>基于c语言我们开发了应用程序foo，如果把c移植到别的平台上去，就是可以把c编译成另一种平台的汇编代码，那么我们的程序如果没有使用太多的诡异特性的话，一般就能在这种新的平台运行。各管一层。</p>
<ul>
<li><p><strong>make与makefile以及项目文件</strong></p>

</ul>
<p>如果有成千上万个源代码，而且还有互相依赖，这时你修改了某个源代码，那么凡是依赖它的源代码都应该重新编译。一行行的输入</p>
<pre><code class="c hljs">gcc first.c -o first.o
gcc second.c -o second.o
...</code></pre>
<p>这是很繁琐的。人们发展了make这个好玩意。它通过makefile确定依赖关系和生成规则，并且根据时间戳，递归的把凡是修改时间比目标代码更新的文件及其依赖于它的文件都重新编译一下。一个典型的makefile长这样，</p>
<pre><code class="julia hljs">foo.o:foo.c
    gcc foo.c -o foo.o
bar.o:bar.c
    gcc bar.c -o bar.o
myprogram:foo.o bar.o
    gcc foo.o bar.o -o myprogram</code></pre>
<p>核心就是，依赖关系&#43;生成规则。而为了适应不同的平台，适应批量的处理，还能定义变量，使用通配符。关于make及makefile可以看看一看此篇文字，不用看的太多，理解makefile描述的就是依赖关系&#43;生成规则就够了。</p>
<ul>
<li><p><strong>从make，到automake，configure，再到qmake，wmake</strong></p>

</ul>
<p>经常碰到的事情是一个程序在不同的平台上编译，使用不同的makefile，因为在makefile中还得说明使用什么编译器，INCLUDE目录在哪里，库文件在哪里。人们总是想偷懒的，所以又发展了自动生成makefile的工具，有什么automake啊，configure啊之类的。所以我们经常在开源软件包中看到readme说明的安装过程像这样，</p>
<pre><code class="julia hljs">./configure --prefix=/usr/<span class=hljs-keyword >local</span> FC=ifort 
make
make install</code></pre>
<p>此外，还有qmake，wmake这些各种古怪稀奇的玩意。qmake是qt搞的，wmake是cfd软件openfoam重度使用的。基本道理都差不多。wmake貌似是会递归的查找当前目录及其子目录，然后在每个目录都去给编译一下。</p>
<p>实际上，visual studio系列也有这么个东西，不过不是makefile&#43;make。它叫项目文件。在一个解决方案下可能有多个项目，每个项目就有个项目文件。如果我们用文本编辑工具打开这个项目文件的话，发现它说描述的是同样的事情，就是依赖关系和生成规则。当然visual studio系列也支持make，有个nmake工具。</p>
<ul>
<li><p><strong>cmake也是个函数</strong></p>

</ul>
<p>那么，能不能根据依赖关系和目标关系自动生成makefile，自动生成项目文件这些呢？你说对了，还真是有。cmake就是这么个工具。它根据CMakelists.txt和你选择的工具链去生成makefile这些，或者生成visual studio需要的项目文件。然后调用你的工具链去编译代码。</p>
<p>从我们前面的理解来看，cmake也是个函数，它的输入就是CMakelists.txt等，然后输出就是你所要的项目文件等。</p>
<p>对c/cpp/fortran系列来说，jetbrains出品的CLion堪称利器。（jetbrains的工具，学术免费，开源开发免费。）</p>
<h2 id="递归"><a href="#递归" class=header-anchor >递归</a></h2>
<ul>
<li><p>斐波拉契数列与递归</p>

<li><p>递归与循环</p>

<li><p>四则混合运算、表达式树与递归</p>

</ul>
<h2 id="交互式编程与解释器"><a href="#交互式编程与解释器" class=header-anchor >交互式编程与解释器</a></h2>
<p>我们提交一个Add 3 4</p>
<ul>
<li><p>抽象语法树</p>

<li><p>递归处理是解释器的处理办法</p>

</ul>
<h2 id="抽象与封装"><a href="#抽象与封装" class=header-anchor >抽象与封装</a></h2>
<ul>
<li><p>结构体，有理数的加减乘除</p>

<li><p>结构体演变为类</p>

<li><p>以类为基础的面向对象编程，封装，继承，多态</p>

<li><p>算法的不依赖于具体的类型</p>

</ul>
<p>C&#43;&#43;的模板类 julia的参数类型</p>
<ul>
<li><p>java的java、class、jar</p>

<li><p>julia的多重分发</p>

<li><p>go的嵌入体</p>

<li><p>库与头文件、包、模块</p>

<li><p>软件包与生态</p>

<li><p>名字空间</p>

</ul>
<h2 id="图形界面与低代码开发"><a href="#图形界面与低代码开发" class=header-anchor >图形界面与低代码开发</a></h2>
<ul>
<li><p>从gcc、gdb到IDE</p>

<li><p>儿童编程Scratch与背后的code</p>

</ul>
<p>-从delphi、C#、QT到浏览器</p>
<h2 id="如何进行进一步学习"><a href="#如何进行进一步学习" class=header-anchor >如何进行进一步学习</a></h2>
<ul>
<li><p>学习一门编程语言，掌握关键语言特性，忽略次要特性</p>

<li><p>注意语言特有的那些区别于其他语言的地方</p>

<li><p>编程与算法，sicp与leecode</p>

<li><p>食材、调料与大餐</p>

<li><p>搜索引擎、github</p>

</ul>
<h2 id="再看抽象与封装"><a href="#再看抽象与封装" class=header-anchor >再看抽象与封装</a></h2>
<ul>
<li><p>硬件的一层又一层抽象</p>

<li><p>对用户友好与对机器友好</p>

</ul>
<p>从javascript到typescript 从0101到汇编到c，再到今天的高级语言</p>
<ul>
<li><p>软件的一层又一层抽象</p>

</ul>
<p>从ops说说计算方法与硬件无关性 DSL与库</p>
<ul>
<li><p>知识的结构</p>

</ul>
<p>欧几里得几何原本</p>
<p>自然数的定义</p>
<p>让我们谈谈lambda演算</p>
<p>lisp的本质，xml，ant</p>
<ul>
<li><p>站在巨人的肩膀上</p>

</ul>
<h2 id="不是最后的最后"><a href="#不是最后的最后" class=header-anchor >不是最后的最后</a></h2>
<p>吾生也有涯，而知也无涯</p>
<p>知识在爆炸，与时俱进</p>
<p>从下到上的学习与从上到下的做事，不同的阶段，框架与细节相结合</p>
<p>学习与成功五要素，学习的能力、学习的驱动力、学习的路径、机缘、持续努力</p>
<p>前进的方法：实践、认识、再实践、再认识</p>
<div class=page-foot >
    <div class=copyright >
      &copy; Mingtao Li。最后更新：May 13, 2022。本站使用<a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>和<a href="https://julialang.org">Julia编程语言</a>构建。
    </div>
</div>
  </div>
      </div> 
  </div> 
  <script src="/enpo811203/libs/pure/ui.min.js"></script>